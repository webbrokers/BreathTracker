<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Breath Tracker — лёгкий MVP</title>
<style>
  :root {
    --bg:#f7fafc; --card:#ffffff; --fg:#0f172a; --muted:#64748b; --line:#e2e8f0;
    --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --bad:#ef4444; --curve:#0ea5e9;
    --ref:#cbd5f5;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
  header{padding:14px 18px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;flex-wrap:wrap;background:var(--card)}
  header h1{font-size:16px;margin:0 8px 0 0;font-weight:700}
  button,select,input[type="range"]{appearance:none;background:#eef2f7;border:1px solid #d6dee7;color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
  button:hover{border-color:#c7d2e0}
  button.primary{background:#e7efff;border-color:#c7dbff}
  button.recording{background:#fee2e2;border-color:#fecaca;color:#b91c1c}
  main{display:grid;grid-template-columns:1fr 340px;gap:0}
  #left{padding:12px}
  #right{padding:12px;border-left:1px solid var(--line);background:var(--card)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .label{color:var(--muted)}
  .stat{display:grid;grid-template-columns:1fr auto;gap:6px;padding:8px 0;border-bottom:1px dashed var(--line)}
  .stat b{font-weight:700}
  canvas{display:block;width:100%;height:340px;background:#fff;border:1px solid var(--line);border-radius:12px}
  .note{color:var(--muted);font-size:12px;margin-top:6px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid var(--line);border-radius:999px;color:var(--muted);font-size:12px;background:#fff}
  .legend{display:flex;gap:8px;margin:8px 0 0 0}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.inhale{background:var(--good)}
  .dot.exhale{background:var(--warn)}
  .dot.peak{background:#38bdf8}
  .dot.trough{background:#fb7185}
  .grid{display:grid;gap:6px}
  .spacer{flex:1}
  a.link{color:var(--accent);text-decoration:none}
  .bar{height:10px;background:#e5e7eb;border-radius:6px;overflow:hidden;border:1px solid var(--line)}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#93c5fd,#60a5fa)}
  .record-badge{font-size:12px;font-weight:600;display:flex;align-items:center;gap:6px;color:var(--muted)}
  .record-badge::before{content:"";width:8px;height:8px;border-radius:50%;background:var(--muted);box-shadow:0 0 0 0 rgba(239,68,68,0.4);transition:all .2s ease}
  .record-badge.on{color:#b91c1c}
  .record-badge.on::before{background:#ef4444;box-shadow:0 0 0 6px rgba(239,68,68,0.22)}
  .orb-wrapper{margin:18px 0 0;display:flex;align-items:center;gap:18px;flex-wrap:wrap}
  .orb-wrapper small{color:var(--muted)}
  #breathOrb{width:120px;height:120px;border-radius:50%;background:radial-gradient(circle at center,#dbeafe,#93c5fd);box-shadow:0 6px 24px rgba(37,99,235,0.35);transition:transform .15s ease,box-shadow .15s ease,background .2s ease}
  #breathOrb.inhale{background:radial-gradient(circle at center,#dcfce7,#86efac)}
  #breathOrb.exhale{background:radial-gradient(circle at center,#fef3c7,#fcd34d)}
  #breathOrb.idle{opacity:0.7}
  #breathOrb::after{content:"";position:absolute;inset:6px;border-radius:50%;border:1px dashed rgba(255,255,255,0.5)}
  #breathOrb{position:relative}
  @media (max-width:980px){
    main{grid-template-columns:1fr}
    #right{border-left:none;border-top:1px solid var(--line)}
    header{flex-direction:column;align-items:flex-start}
  }
</style>
</head>
<body>
<header>
  <h1>Breath Tracker — лёгкий MVP</h1>
  <div class="row">
    <button id="record" class="primary">Запись</button>
    <button id="stop">Стоп</button>
    <button id="export">Экспорт CSV</button>
  </div>
  <div class="spacer"></div>
  <span id="recordBadge" class="record-badge">Нет записи</span>
  <span class="pill">Микрофон • локальная обработка</span>
</header>

<main>
  <section id="left">
    <canvas id="plot" width="1400" height="360"></canvas>
    <div class="legend">
      <span class="pill"><span class="dot inhale"></span> Вдох</span>
      <span class="pill"><span class="dot exhale"></span> Выдох</span>
      <span class="pill"><span class="dot peak"></span> Пик</span>
      <span class="pill"><span class="dot trough"></span> Впадина</span>
    </div>
    <div class="note">Поднесите микрофон ближе к носу/рту. Если «Уровень» ниже 10–20 %, увеличьте «Усиление» или уменьшите шум.</div>
    <div class="note">Серая линия — эталонный цикл (вдох 4 с → пауза 2 с → выдох 6 с → пауза 3 с).</div>
    <div class="orb-wrapper">
      <div id="breathOrb" class="idle"></div>
      <small>«Мембрана» повторяет амплитуду дыхания и помогает использовать интерфейс на мобильных устройствах.</small>
    </div>
  </section>

  <aside id="right">
    <div class="grid">
      <div class="row"><span class="label">Калибровка (с):</span>
        <input id="calibSecs" type="range" min="2" max="12" step="1" value="5">
        <span id="calibVal">5</span>
      </div>
      <div class="row"><span class="label">Сглаживание (EMA):</span>
        <input id="alpha" type="range" min="0.05" max="0.6" step="0.05" value="0.20">
        <span id="alphaVal">0.20</span>
      </div>
      <div class="row"><span class="label">Чувствительность:</span>
        <input id="sens" type="range" min="0" max="4" step="1" value="2">
        <span id="sensVal">Средняя</span>
      </div>
      <div class="row"><span class="label">Усиление (×):</span>
        <input id="gain" type="range" min="1" max="20" step="1" value="6">
        <span id="gainVal">6×</span>
      </div>

      <div class="stat"><span class="label">Статус</span><b id="status">Ожидание</b></div>
      <div class="stat"><span class="label">Дыхание (бр/мин)</span><b id="brpm">—</b></div>
      <div class="stat"><span class="label">Вдох (с)</span><b id="inh">—</b></div>
      <div class="stat"><span class="label">Выдох (с)</span><b id="exh">—</b></div>
      <div class="stat"><span class="label">I:E</span><b id="ie">—</b></div>
      <div class="stat"><span class="label">Регулярность (%)</span><b id="coh">—</b></div>
      <div class="stat"><span class="label">Фаза</span><b id="phase">—</b></div>
      <div class="stat"><span class="label">Уровень</span>
        <div class="bar"><span id="lvlbar"></span></div>
      </div>

      <div class="note">
        Алгоритм: RMS → EMA → адаптивные пороги (медиана + MAD) → пики/впадины по производной. Экспорт — CSV.
      </div>
      <div class="note">Инструмент для биофидбека, не медицинское изделие.</div>
      <div class="note"><a class="link" href="#" id="quick6">Пейсинг 6 бр/мин</a></div>
    </div>
  </aside>
</main>

<script>
(() => {
  const WORKLET_SOURCE = String.raw`
class RmsProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    const input = inputs[0];
    const output = outputs[0];
    if (output && output[0]) {
      output[0].fill(0);
    }
    if (input && input[0] && input[0].length) {
      const ch = input[0];
      let sum = 0;
      for (let i = 0; i < ch.length; i++) {
        const sample = ch[i];
        sum += sample * sample;
      }
      const rms = Math.sqrt(sum / ch.length);
      this.port.postMessage({ rms, frames: ch.length });
    }
    return true;
  }
}
registerProcessor('rms-processor', RmsProcessor);
`;

  const HISTORY_SEC = 30;
  const REF_BLOCK = 1024;
  const MIN_SWING = 0.002;
  const MIN_MAD = 0.0002;

  // ===== Helpers
  const $ = id => document.getElementById(id);
  function download(filename, text) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], {type: 'text/csv;charset=utf-8;'}));
    a.download = filename; a.click(); URL.revokeObjectURL(a.href);
  }
  function robustStats(arr){
    if (!arr.length) return {median:0, mad:0.0001};
    const a = arr.slice().sort((x,y)=>x-y);
    const m = a[Math.floor(a.length/2)];
    const dev = a.map(v=>Math.abs(v-m)).sort((x,y)=>x-y);
    const mad = dev[Math.floor(dev.length/2)] || 0.0001;
    return {median:m, mad: mad || 0.0001};
  }
  function clampInRange(v,min,max){ return v>=min && v<=max; }
  function levelToRatio(v, median, mad){
    const floor = Math.max(0, median - 1.5*mad);
    const span = Math.max(MIN_MAD*4, mad*8);
    const relative = Math.max(0, v - floor);
    return Math.max(0, Math.min(1, relative / span));
  }

  // ===== DOM
  const recordBtn=$('record'), stopBtn=$('stop'), exportBtn=$('export');
  const recordBadge=$('recordBadge');
  const plot=$('plot'), g=plot.getContext('2d');
  const statusEl=$('status'), brpmEl=$('brpm'), inhEl=$('inh'), exhEl=$('exh'), ieEl=$('ie'), cohEl=$('coh');
  const phaseEl=$('phase');
  const lvlbar=$('lvlbar');
  const alphaRange=$('alpha'), alphaVal=$('alphaVal');
  const calibRange=$('calibSecs'), calibVal=$('calibVal');
  const sensRange=$('sens'), sensVal=$('sensVal');
  const gainRange=$('gain'), gainVal=$('gainVal');
  const quick6=$('quick6');
  const orb=$('breathOrb');

  const sensLabels=['Очень низкая','Ниже ср.','Средняя','Выше ср.','Очень высокая'];
  const sensShift=[-0.8,-0.4,0,0.4,0.8];

  let canvasWidth=plot.clientWidth||plot.width;
  let canvasHeight=plot.clientHeight||plot.height;
  function resizeCanvas(){
    canvasWidth = plot.clientWidth||plot.width;
    canvasHeight = plot.clientHeight||plot.height;
    if (!canvasWidth) canvasWidth = plot.width;
    if (!canvasHeight) canvasHeight = 340;
    const dpr = window.devicePixelRatio || 1;
    plot.width = Math.floor(canvasWidth * dpr);
    plot.height = Math.floor(canvasHeight * dpr);
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas, {passive:true});
  resizeCanvas();

  // ===== State
  let audioCtx=null, source=null, processor=null, stream=null, workletUrl=null;
  let ema=0, running=false, calibrating=false, calibEnd=0;
  let envHistory=[], derPrev=0, prevEma=0;
  let lastPeak=null, lastTrough=null, inhaleStartT=null;
  let lastCycle=null, cycles=[], drawPoints=[];
  let paceOn=false, paceStart=0;
  let lastEnvelopeTime=null;
  let currentPhase='';
  let recording=false, recordSegments=[], activeRecordSegment=null;
  let lastDisplayRatio=0, lastPlotStoreTime=0;
  let phaseSegments=[], activePhaseSegment=null;
  let phaseEvents=[];
  let resumeBound=false;

  const DRAW_INTERVAL = 0.12; // ~8 Гц
  const PHASE_COLORS = {
    'Вдох':'var(--good)',
    'Выдох':'var(--warn)',
    'Пик':'#38bdf8',
    'Впадина':'#fb7185',
    '': 'var(--curve)'
  };
  const IDEAL_PATTERN = [
    {type:'Вдох', dur:4},
    {type:'Пауза1', dur:2},
    {type:'Выдох', dur:6},
    {type:'Пауза2', dur:3}
  ];
  const IDEAL_TOTAL = IDEAL_PATTERN.reduce((s,p)=>s+p.dur,0);

  // UI binds
  alphaRange.oninput=()=>alphaVal.textContent=(+alphaRange.value).toFixed(2);
  calibRange.oninput=()=>calibVal.textContent=calibRange.value;
  sensRange.oninput=()=>sensVal.textContent=sensLabels[sensRange.value|0];
  gainRange.oninput=()=>gainVal.textContent=gainRange.value+'×';
  quick6.onclick=(e)=>{
    e.preventDefault();
    paceOn=!paceOn;
    paceStart=performance.now()/1000;
    quick6.textContent=paceOn?'Остановить метроном':'Пейсинг 6 бр/мин';
  };

  alphaRange.oninput();
  calibRange.oninput();
  sensRange.oninput();
  gainRange.oninput();
  updateRecordingUI();

  function updateRecordingUI(){
    recordBtn.textContent = recording ? 'Идёт запись' : 'Запись';
    recordBtn.classList.toggle('recording', recording);
    recordBadge.classList.toggle('on', recording);
    recordBadge.textContent = recording ? 'Идёт запись' : 'Нет записи';
  }

  function currentTime(){
    return (lastEnvelopeTime ?? audioCtx?.currentTime) || performance.now()/1000;
  }

  function trimRecordSegments(now=currentTime()){
    recordSegments = recordSegments.filter(seg=>{
      const end = seg.end ?? now;
      return now - end < HISTORY_SEC*2;
    });
  }

  function setRecordingState(next){
    if (next === recording) return;
    recording = next;
    if (recording){
      activeRecordSegment = {start:currentTime(), end:null};
      recordSegments.push(activeRecordSegment);
      trimRecordSegments();
    } else if (activeRecordSegment){
      activeRecordSegment.end = currentTime();
      activeRecordSegment=null;
    }
    updateRecordingUI();
  }

  function isRecordedAt(time){
    const now = currentTime();
    return recordSegments.some(seg=>{
      const segEnd = seg.end ?? now;
      return time >= seg.start && time <= segEnd;
    });
  }

  function setPhase(phase, time=currentTime()){
    currentPhase = phase || '';
    phaseEl.textContent = currentPhase || '—';
    if (running && !calibrating){
      statusEl.textContent = currentPhase || 'Поток активен';
    }
    if (phase==='Вдох' || phase==='Выдох'){
      if (activePhaseSegment && activePhaseSegment.type===phase){
        activePhaseSegment.end = time;
      } else {
        if (activePhaseSegment){
          activePhaseSegment.end = time;
          phaseSegments.push(activePhaseSegment);
        }
        activePhaseSegment = {start:time, end:null, type:phase};
      }
      trimPhaseSegments(time);
    } else if (!phase && activePhaseSegment){
      activePhaseSegment.end = time;
      phaseSegments.push(activePhaseSegment);
      activePhaseSegment=null;
      trimPhaseSegments(time);
    }
  }

  function trimPhaseSegments(now=currentTime()){
    phaseSegments = phaseSegments.filter(seg=>{
      const end = seg.end ?? now;
      return now - end < HISTORY_SEC*2;
    });
  }

  function addPhaseEvent(type, time, value){
    phaseEvents.push({type, t:time, v:value});
    while(phaseEvents.length>400){ phaseEvents.shift(); }
  }

  // ===== Start/Stop
  async function ensureRunning(){
    if (running) return true;
    try{
      await start();
      return true;
    }catch(e){
      console.warn('Не удалось запустить поток', e);
      return false;
    }
  }

  function bindResumeHandler(){
    if (resumeBound) return;
    const resume = ()=>{ if (audioCtx && audioCtx.state==='suspended'){ audioCtx.resume(); } };
    ['touchstart','pointerdown'].forEach(evt=>{
      window.addEventListener(evt, resume, {passive:true});
    });
    resumeBound=true;
  }

  async function start(){
    if (running) return;
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
      });
    }catch(e){
      statusEl.textContent = 'Нужен доступ к микрофону';
      phaseEl.textContent = '—';
      updateRecordingUI();
      throw e;
    }
    audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    bindResumeHandler();
    source = audioCtx.createMediaStreamSource(stream);

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = +gainRange.value;

    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=20;

    try{
      processor = await createWorkletNode();
    }catch(e){
      alert('AudioWorklet недоступен: '+e.message);
      stop();
      return;
    }

    source.connect(gainNode);
    gainNode.connect(hp);
    hp.connect(processor);
    processor.connect(audioCtx.destination);

    resetLogic(true);
    running=true; calibrate();
    statusEl.textContent='Калибровка...';
    phaseEl.textContent='—';
  }

  function stop(){
    running=false; calibrating=false;
    if (processor){
      try{processor.disconnect();}catch{}
      if (processor.port) processor.port.onmessage=null;
    }
    if (audioCtx){ try{audioCtx.close();}catch{} }
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    if (workletUrl){ URL.revokeObjectURL(workletUrl); workletUrl=null; }
    audioCtx=source=processor=stream=null;
    resetLogic(true);
    setRecordingState(false);
    recordSegments=[]; activeRecordSegment=null;
    statusEl.textContent='Ожидание';
    lvlbar.style.width='0%';
    brpmEl.textContent=inhEl.textContent=exhEl.textContent=ieEl.textContent=cohEl.textContent='—';
    paceOn=false; quick6.textContent='Пейсинг 6 бр/мин';
    updateOrb(0,'');
  }

  recordBtn.onclick=async ()=>{
    const ok = await ensureRunning();
    if (!ok) return;
    setRecordingState(!recording);
  };
  stopBtn.onclick=()=>{
    stop();
  };

  async function createWorkletNode(){
    if (!audioCtx || !audioCtx.audioWorklet || typeof AudioWorkletNode === 'undefined'){
      throw new Error('браузер не поддерживает AudioWorklet');
    }
    workletUrl = URL.createObjectURL(new Blob([WORKLET_SOURCE], {type:'application/javascript'}));
    await audioCtx.audioWorklet.addModule(workletUrl);
    const node = new AudioWorkletNode(audioCtx,'rms-processor',{
      numberOfInputs:1,
      numberOfOutputs:1,
      outputChannelCount:[1]
    });
    node.port.onmessage = e => handleEnvelope(e.data);
    return node;
  }

  // ===== Core processing
  function handleEnvelope(payload){
    if (!audioCtx) return;
    const msg = (typeof payload === 'number') ? {rms:payload, frames:REF_BLOCK} : (payload || {});
    const rms = msg.rms ?? 0;
    const frames = msg.frames || REF_BLOCK;

    const alphaUser = +alphaRange.value;
    const scaledAlpha = 1 - Math.pow(1 - alphaUser, Math.max(1, frames)/REF_BLOCK);
    ema = scaledAlpha*rms + (1-scaledAlpha)*ema;

    envHistory.push(ema);
    if (envHistory.length > 4800) envHistory.shift();

    const der = ema - prevEma;
    prevEma = ema;

    if (lastEnvelopeTime==null) lastEnvelopeTime = audioCtx.currentTime;
    else lastEnvelopeTime += frames / audioCtx.sampleRate;
    const now = lastEnvelopeTime;
    trimRecordSegments(now);

    if (now - lastPlotStoreTime >= DRAW_INTERVAL){
      drawPoints.push({t:now, v:ema});
      lastPlotStoreTime = now;
    }
    while(drawPoints.length && now - drawPoints[0].t > HISTORY_SEC+2){ drawPoints.shift(); }

    const {median, mad} = robustStats(envHistory);
    const safeMad = Math.max(mad, MIN_MAD);
    const hi = median + (1.8 + sensShift[sensRange.value|0]) * safeMad;
    const lo = Math.max(median - 0.2*safeMad, 0);

    if (derPrev>0 && der<=0 && ema>hi){
      lastPeak = {t:now, v:ema};
      addPhaseEvent('Пик', now, ema);
      setPhase('Выдох', now);
      if (lastTrough){
        const tInhale = now - lastTrough.t;
        if (!lastCycle) lastCycle={};
        lastCycle.tInhale = clampInRange(tInhale,0.3,15)?tInhale:undefined;
        inhaleStartT = lastTrough.t;
      }
    }

    if (derPrev<0 && der>=0 && ema<lo){
      lastTrough = {t:now, v:ema};
      addPhaseEvent('Впадина', now, ema);
      setPhase('Вдох', now);
      if (lastPeak){
        const tExhale = now - lastPeak.t;
        if (!lastCycle) lastCycle={};
        lastCycle.tExhale = clampInRange(tExhale,0.3,20)?tExhale:undefined;

        if (inhaleStartT!=null){
          lastCycle.tStart = inhaleStartT;
          lastCycle.tEnd = now;
          lastCycle.tCycle = (lastCycle.tInhale||0) + (lastCycle.tExhale||0);
          lastCycle.peakV = lastPeak.v; lastCycle.troughV = lastTrough.v;
          const swing = Math.abs((lastCycle.peakV||0) - (lastCycle.troughV||0));
          const minSwing = Math.max(MIN_SWING, 0.35*safeMad);
          if (clampInRange(lastCycle.tCycle,1.5,15) && swing>=minSwing){
            cycles.push(lastCycle);
            if (cycles.length>120) cycles.shift();
          }
          lastCycle.recorded = isRecordedAt(now);
          lastCycle = {};
        }
      }
    }
    derPrev = der;

    if (calibrating){
      const remain = Math.max(0, calibEnd - now);
      statusEl.textContent = `Калибровка: ${remain.toFixed(1)} с`;
      if (remain<=0){
        calibrating=false;
        statusEl.textContent = currentPhase || 'Поток активен';
      }
    } else if (running){
      statusEl.textContent = currentPhase || 'Поток активен';
    }
    phaseEl.textContent = currentPhase || '—';

    updateStats(ema, median, safeMad);
  }

  function resetLogic(full=false){
    ema=0; envHistory=[]; derPrev=0; prevEma=0; lastPeak=lastTrough=null; inhaleStartT=null;
    lastEnvelopeTime=null; lastPlotStoreTime=0;
    phaseSegments=[]; activePhaseSegment=null; phaseEvents=[];
    setPhase('', currentTime());
    if (full){ cycles=[]; lastCycle=null; drawPoints=[]; }
  }
  function currentBRPM(){
    if (cycles.length<2) return null;
    const lastN=cycles.slice(-5).map(c=>c.tCycle).filter(Boolean);
    if (!lastN.length) return null;
    const med=lastN.sort((a,b)=>a-b)[Math.floor(lastN.length/2)];
    return med?60/med:null;
  }
  function updateStats(level, median, mad){
    const ratio = levelToRatio(level, median, mad);
    lastDisplayRatio = ratio;
    lvlbar.style.width = (ratio*100).toFixed(0)+'%';
    updateOrb(ratio, currentPhase);

    const br = currentBRPM();
    brpmEl.textContent = br ? br.toFixed(1) : '—';

    const last = cycles[cycles.length-1];
    inhEl.textContent = last?.tInhale ? last.tInhale.toFixed(2) : '—';
    exhEl.textContent = last?.tExhale ? last.tExhale.toFixed(2) : '—';
    ieEl.textContent  = (last?.tInhale && last?.tExhale) ? (last.tInhale/last.tExhale).toFixed(2) : '—';

    const last8 = cycles.slice(-8).map(c=>c.tCycle).filter(Boolean);
    if (last8.length>=3){
      const mean = last8.reduce((s,x)=>s+x,0)/last8.length;
      const sd   = Math.sqrt(last8.reduce((s,x)=>s+(x-mean)*(x-mean),0)/last8.length);
      let coh = 1 - (sd/mean);
      coh = Math.max(0, Math.min(1, coh));
      cohEl.textContent = Math.round(coh*100);
    } else cohEl.textContent='—';
  }

  // ===== Drawing
  function drawLoop(){
    g.clearRect(0,0,canvasWidth,canvasHeight);
    const latestTime = drawPoints.length ? drawPoints[drawPoints.length-1].t : 0;
    const pxPerSec = canvasWidth / HISTORY_SEC;

    g.strokeStyle='#e5e7eb'; g.lineWidth=1; g.globalAlpha=1;
    g.beginPath();
    for (let sec=0; sec<=HISTORY_SEC; sec+=5){
      const x = canvasWidth - sec*pxPerSec;
      g.moveTo(x,0); g.lineTo(x,canvasHeight);
    }
    for (let y=0;y<=canvasHeight;y+=60){ g.moveTo(0,y); g.lineTo(canvasWidth,y); }
    g.stroke();

    g.fillStyle='#94a3b8'; g.font='12px "Inter", system-ui';
    for (let sec=0; sec<=HISTORY_SEC; sec+=5){
      const x = canvasWidth - sec*pxPerSec + 4;
      const label = sec===0 ? '0 с' : `-${sec} с`;
      g.fillText(label, Math.max(4, Math.min(canvasWidth-34, x)), canvasHeight-8);
    }

    if (currentPhase){
      g.save();
      g.globalAlpha=0.08;
      g.fillStyle = currentPhase==='Вдох' ? 'var(--good)' : 'var(--warn)';
      g.fillRect(0, canvasHeight-40, canvasWidth, 40);
      g.restore();
    }

    if (recordSegments.length && latestTime){
      g.save();
      g.fillStyle='rgba(239,68,68,0.06)';
      recordSegments.forEach(seg=>{
        const segEnd = seg.end ?? latestTime;
        if (segEnd < latestTime - HISTORY_SEC) return;
        const segStart = Math.max(seg.start, latestTime - HISTORY_SEC);
        const width = segEnd - segStart;
        if (width<=0) return;
        const x1 = canvasWidth - Math.max(0,(latestTime - segEnd)*pxPerSec);
        const x2 = canvasWidth - Math.max(0,(latestTime - segStart)*pxPerSec);
        g.fillRect(x1,0,Math.max(2,x2-x1),canvasHeight);
      });
      g.restore();
    }

    drawReferenceCurve(latestTime, pxPerSec);

    if (drawPoints.length){
      const stats = robustStats(envHistory.length?envHistory:drawPoints.map(p=>p.v));
      const toRatio = (val)=>levelToRatio(val, stats.median, stats.mad);
      const toY = (val)=>{
        const r = toRatio(val);
        return canvasHeight - r*(canvasHeight-6) - 3;
      };

      let lastX=null, lastY=null, lastColor=null, pathActive=false;
      g.lineWidth=2;
      drawPoints.forEach((pt, idx)=>{
        const x = canvasWidth - Math.max(0,(latestTime - pt.t)*pxPerSec);
        const y = toY(pt.v);
        const midT = idx===0 ? pt.t : (pt.t + drawPoints[idx-1].t)/2;
        const color = colorForTime(midT);
        if (!pathActive || color!==lastColor){
          if (pathActive) g.stroke();
          g.beginPath();
          g.strokeStyle = color || PHASE_COLORS[''];
          g.moveTo(lastX ?? x, lastY ?? y);
          pathActive=true;
        }
        g.lineTo(x,y);
        lastX=x; lastY=y; lastColor=color;
      });
      if (pathActive) g.stroke();

      const cutoff = latestTime - HISTORY_SEC - 0.5;
      phaseEvents.forEach(evt=>{
        if (!evt || evt.t<cutoff) return;
        const x = canvasWidth - Math.max(0,(latestTime - evt.t)*pxPerSec);
        if (x<0 || x>canvasWidth) return;
        const y = toY(evt.v);
        const color = PHASE_COLORS[evt.type] || '#38bdf8';
        g.fillStyle = color;
        g.beginPath(); g.arc(x, y, 5, 0, Math.PI*2); g.fill();
      });
    }

    if (paceOn){
      const t = performance.now()/1000 - paceStart;
      const period = 10, inhaleFrac = 0.45;
      const ph = (t%period)/period;
      const inhale = ph<inhaleFrac;
      const r = 10 + (inhale? (ph/inhaleFrac):(1-(ph-inhaleFrac)/(1-inhaleFrac)))*20;
      g.save();
      g.globalAlpha=0.9;
      g.fillStyle = inhale? 'var(--good)' : 'var(--warn)';
      g.beginPath(); g.arc(canvasWidth-30, canvasHeight-30, r, 0, Math.PI*2); g.fill();
      g.restore();
    }
    requestAnimationFrame(drawLoop);
  }

  function colorForTime(ts){
    const now = currentTime();
    if (activePhaseSegment){
      const end = activePhaseSegment.end ?? now;
      if (ts>=activePhaseSegment.start && ts<=end){
        return PHASE_COLORS[activePhaseSegment.type] || PHASE_COLORS[''];
      }
    }
    for (let i=phaseSegments.length-1; i>=0; i--){
      const seg = phaseSegments[i];
      const end = seg.end ?? now;
      if (ts>=seg.start && ts<=end){
        return PHASE_COLORS[seg.type] || PHASE_COLORS[''];
      }
    }
    return PHASE_COLORS[''];
  }

  function idealRatioAt(time){
    if (!isFinite(time) || !IDEAL_TOTAL) return 0;
    let local = ((time % IDEAL_TOTAL) + IDEAL_TOTAL) % IDEAL_TOTAL;
    for (const seg of IDEAL_PATTERN){
      if (local <= seg.dur){
        if (seg.type==='Вдох') return local/seg.dur;
        if (seg.type==='Выдох') return 1 - local/seg.dur;
        if (seg.type==='Пауза1') return 1;
        if (seg.type==='Пауза2') return 0;
        return 0;
      }
      local -= seg.dur;
    }
    return 0;
  }

  function drawReferenceCurve(latestTime, pxPerSec){
    if (!latestTime || !pxPerSec) return;
    g.save();
    g.lineWidth=1.2;
    g.strokeStyle='rgba(148,163,184,0.7)';
    g.setLineDash([6,6]);
    g.beginPath();
    for (let x=0; x<=canvasWidth; x+=6){
      const t = latestTime - (canvasWidth - x)/pxPerSec;
      const ratio = idealRatioAt(t);
      const y = canvasHeight - ratio*(canvasHeight-6) - 3;
      if (x===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();
    g.restore();
    g.setLineDash([]);
  }

  function updateOrb(ratio, phase){
    if (!orb) return;
    const level = isFinite(ratio)?ratio:0;
    const scale = 0.85 + level*0.5;
    orb.style.transform = `scale(${scale.toFixed(3)})`;
    orb.classList.toggle('inhale', phase==='Вдох');
    orb.classList.toggle('exhale', phase==='Выдох');
    orb.classList.toggle('idle', level<0.02 && !running);
  }
  requestAnimationFrame(drawLoop);

  window.addEventListener('load', ()=>{
    ensureRunning();
  });

  // ===== Export
  exportBtn.onclick = () => {
    const recordedOnly = cycles.filter(c=>c.recorded);
    const dataset = recordedOnly.length ? recordedOnly : cycles;
    const rows = [['t_start(s)','t_end(s)','cycle(s)','inhale(s)','exhale(s)','brpm','I:E','peak_amp','trough_amp','recorded']];
    for (const c of dataset) {
      const brpm = c.tCycle?60/c.tCycle:'';
      const ie = (c.tInhale&&c.tExhale)?(c.tInhale/c.tExhale).toFixed(2):'';
      rows.push([
        c.tStart?.toFixed(3)||'',
        c.tEnd?.toFixed(3)||'',
        c.tCycle?.toFixed(3)||'',
        c.tInhale?.toFixed(3)||'',
        c.tExhale?.toFixed(3)||'',
        brpm?brpm.toFixed(2):'',
        ie,
        c.peakV?.toFixed(5)||'',
        c.troughV?.toFixed(5)||'',
        c.recorded?1:0
      ]);
    }
    download('breath_session.csv', rows.map(r=>r.join(',')).join('\n'));
  };

  // ===== Calibration
  function calibrate(){
    if (!audioCtx) return;
    calibrating=true;
    calibEnd = audioCtx.currentTime + (parseInt(calibRange.value,10)||5);
    statusEl.textContent='Калибровка...';
    phaseEl.textContent = currentPhase || '—';
  }

})();
</script>
</body>
</html>
