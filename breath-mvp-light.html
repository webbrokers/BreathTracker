<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Breath Tracker — лёгкий MVP</title>
<style>
  :root {
    --bg:#f7fafc; --card:#ffffff; --fg:#0f172a; --muted:#64748b; --line:#e2e8f0;
    --accent:#2563eb; --good:#16a34a; --warn:#f59e0b; --bad:#ef4444; --curve:#0ea5e9;
    --ref:#cbd5f5;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
  header{padding:14px 18px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;flex-wrap:wrap;background:var(--card)}
  header h1{font-size:16px;margin:0 8px 0 0;font-weight:700}
  button,select,input[type="range"]{appearance:none;background:#eef2f7;border:1px solid #d6dee7;color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
  button:hover{border-color:#c7d2e0}
  button.primary{background:#e7efff;border-color:#c7dbff}
  button.recording{background:#fee2e2;border-color:#fecaca;color:#b91c1c}
  main{display:grid;grid-template-columns:1fr 340px;gap:0}
  #left{padding:12px}
  #right{padding:12px;border-left:1px solid var(--line);background:var(--card)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .label{color:var(--muted)}
  .stat{display:grid;grid-template-columns:1fr auto;gap:6px;padding:8px 0;border-bottom:1px dashed var(--line)}
  .stat b{font-weight:700}
  canvas{display:block;width:100%;height:340px;background:#fff;border:1px solid var(--line);border-radius:12px}
  .note{color:var(--muted);font-size:12px;margin-top:6px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid var(--line);border-radius:999px;color:var(--muted);font-size:12px;background:#fff}
  .grid{display:grid;gap:6px}
  .spacer{flex:1}
  a.link{color:var(--accent);text-decoration:none}
  .bar{height:10px;background:#e5e7eb;border-radius:6px;overflow:hidden;border:1px solid var(--line)}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#93c5fd,#60a5fa)}
  .record-badge{font-size:12px;font-weight:600;display:flex;align-items:center;gap:6px;color:var(--muted)}
  .record-badge::before{content:"";width:8px;height:8px;border-radius:50%;background:var(--muted);box-shadow:0 0 0 0 rgba(239,68,68,0.4);transition:all .2s ease}
  .record-badge.on{color:#b91c1c}
  .record-badge.on::before{background:#ef4444;box-shadow:0 0 0 6px rgba(239,68,68,0.22)}
  .orb-wrapper{position:fixed;left:50%;bottom:32px;transform:translateX(-50%);display:flex;flex-direction:column;align-items:center;gap:8px;pointer-events:none;z-index:10}
  .orb-wrapper small{color:var(--muted);text-align:center;max-width:320px}
  #breathOrb{width:30px;height:30px;border-radius:50%;background:radial-gradient(circle at center,#dbeafe,#93c5fd);box-shadow:0 4px 18px rgba(37,99,235,0.35);transition:background .2s ease,box-shadow .2s ease}
  #breathOrb.inhale{background:radial-gradient(circle at center,#dcfce7,#86efac)}
  #breathOrb.exhale{background:radial-gradient(circle at center,#fef3c7,#fcd34d)}
  #breathOrb.idle{opacity:0.7}
  #breathOrb::after{content:"";position:absolute;inset:6px;border-radius:50%;border:1px dashed rgba(255,255,255,0.5)}
  #breathOrb{position:relative}
  @media (max-width:980px){
    main{grid-template-columns:1fr}
    #right{border-left:none;border-top:1px solid var(--line)}
    header{flex-direction:column;align-items:flex-start}
  }
</style>
</head>
<body>
<header>
  <h1>Breath Tracker — лёгкий MVP</h1>
  <div class="row">
    <button id="record" class="primary">Запись</button>
    <button id="stop">Стоп</button>
    <button id="export">Экспорт CSV</button>
  </div>
  <div class="spacer"></div>
  <span id="recordBadge" class="record-badge">Нет записи</span>
  <span class="pill">Микрофон • локальная обработка</span>
</header>

<main>
  <section id="left">
    <canvas id="plot" width="1400" height="360"></canvas>
    <div class="note">Поднесите микрофон ближе к носу/рту. Если «Уровень» ниже 10–20 %, увеличьте «Усиление» или уменьшите шум.</div>
    <div class="note">Горизонтальная шкала показывает 60 с истории, вертикальная — уровень сигнала в дБ (от -70 до 0).</div>
    <div class="orb-wrapper">
      <div id="breathOrb" class="idle"></div>
      <small>«Мембрана» повторяет амплитуду дыхания и помогает использовать интерфейс на мобильных устройствах.</small>
    </div>
  </section>

  <aside id="right">
    <div class="grid">
      <div class="row"><span class="label">Калибровка (с):</span>
        <input id="calibSecs" type="range" min="2" max="12" step="1" value="5">
        <span id="calibVal">5</span>
      </div>
      <div class="row"><span class="label">Сглаживание (EMA):</span>
        <input id="alpha" type="range" min="0.05" max="0.6" step="0.05" value="0.20">
        <span id="alphaVal">0.20</span>
      </div>
      <div class="row"><span class="label">Чувствительность:</span>
        <input id="sens" type="range" min="0" max="4" step="1" value="2">
        <span id="sensVal">Средняя</span>
      </div>
      <div class="row"><span class="label">Усиление (×):</span>
        <input id="gain" type="range" min="1" max="20" step="1" value="1">
        <span id="gainVal">1×</span>
      </div>

      <div class="stat"><span class="label">Статус</span><b id="status">Ожидание</b></div>
      <div class="stat"><span class="label">Дыхание (бр/мин)</span><b id="brpm">—</b></div>
      <div class="stat"><span class="label">Вдох (с)</span><b id="inh">—</b></div>
      <div class="stat"><span class="label">Выдох (с)</span><b id="exh">—</b></div>
      <div class="stat"><span class="label">I:E</span><b id="ie">—</b></div>
      <div class="stat"><span class="label">Регулярность (%)</span><b id="coh">—</b></div>
      <div class="stat"><span class="label">Фаза</span><b id="phase">—</b></div>
      <div class="stat"><span class="label">Уровень</span>
        <div class="bar"><span id="lvlbar"></span></div>
      </div>

      <div class="note">
        Алгоритм: RMS → EMA → адаптивные пороги (медиана + MAD) → пики/впадины по производной. Экспорт — CSV.
      </div>
      <div class="note">Инструмент для биофидбека, не медицинское изделие.</div>
      <div class="note"><a class="link" href="#" id="quick6">Пейсинг 6 бр/мин</a></div>
    </div>
  </aside>
</main>

<script>
(() => {
  const WORKLET_SOURCE = String.raw`
class RmsProcessor extends AudioWorkletProcessor {
  process(inputs, outputs) {
    const input = inputs[0];
    const output = outputs[0];
    if (output && output[0]) {
      output[0].fill(0);
    }
    if (input && input[0] && input[0].length) {
      const ch = input[0];
      let sum = 0;
      for (let i = 0; i < ch.length; i++) {
        const sample = ch[i];
        sum += sample * sample;
      }
      const rms = Math.sqrt(sum / ch.length);
      this.port.postMessage({ rms, frames: ch.length });
    }
    return true;
  }
}
registerProcessor('rms-processor', RmsProcessor);
`;

  const HISTORY_SEC = 60;
  const REF_BLOCK = 1024;
  const MIN_SWING = 0.002;
  const MIN_MAD = 0.0002;
  const DRAW_INTERVAL = 0.1; // 10 Гц
  const DB_MIN = -70;
  const DB_MAX = 0;
  const MAX_GHOSTS = 5;
  const GHOST_RESOLUTION = 180;
  const ORB_MIN = 30;
  const ORB_MAX = 200;
  const ORB_INTERVAL_MS = 1000/20;

  // ===== Helpers
  const $ = id => document.getElementById(id);
  function download(filename, text) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], {type: 'text/csv;charset=utf-8;'}));
    a.download = filename; a.click(); URL.revokeObjectURL(a.href);
  }
  function robustStats(arr){
    if (!arr.length) return {median:0, mad:0.0001};
    const a = arr.slice().sort((x,y)=>x-y);
    const m = a[Math.floor(a.length/2)];
    const dev = a.map(v=>Math.abs(v-m)).sort((x,y)=>x-y);
    const mad = dev[Math.floor(dev.length/2)] || 0.0001;
    return {median:m, mad: mad || 0.0001};
  }
  function clampInRange(v,min,max){ return v>=min && v<=max; }
  function rmsToDb(v){
    const safe = Math.max(v, 1e-8);
    const log10 = Math.log10 ? Math.log10(safe) : (Math.log(safe)/Math.LN10);
    return 20 * log10;
  }
  function dbToRatio(db){
    const span = DB_MAX - DB_MIN || 1;
    const clamped = Math.max(DB_MIN, Math.min(DB_MAX, db));
    return (clamped - DB_MIN) / span;
  }
  function rmsToRatio(v){
    return dbToRatio(rmsToDb(v));
  }
  function dbToY(db){
    const ratio = dbToRatio(db);
    return canvasHeight - ratio*(canvasHeight-6) - 3;
  }

  // ===== DOM
  const recordBtn=$('record'), stopBtn=$('stop'), exportBtn=$('export');
  const recordBadge=$('recordBadge');
  const plot=$('plot'), g=plot.getContext('2d');
  const statusEl=$('status'), brpmEl=$('brpm'), inhEl=$('inh'), exhEl=$('exh'), ieEl=$('ie'), cohEl=$('coh');
  const phaseEl=$('phase');
  const lvlbar=$('lvlbar');
  const alphaRange=$('alpha'), alphaVal=$('alphaVal');
  const calibRange=$('calibSecs'), calibVal=$('calibVal');
  const sensRange=$('sens'), sensVal=$('sensVal');
  const gainRange=$('gain'), gainVal=$('gainVal');
  const quick6=$('quick6');
  const orb=$('breathOrb');

  const sensLabels=['Очень низкая','Ниже ср.','Средняя','Выше ср.','Очень высокая'];
  const sensShift=[-0.8,-0.4,0,0.4,0.8];

  let canvasWidth=plot.clientWidth||plot.width;
  let canvasHeight=plot.clientHeight||plot.height;
  function resizeCanvas(){
    canvasWidth = plot.clientWidth||plot.width;
    canvasHeight = plot.clientHeight||plot.height;
    if (!canvasWidth) canvasWidth = plot.width;
    if (!canvasHeight) canvasHeight = 340;
    const dpr = window.devicePixelRatio || 1;
    plot.width = Math.floor(canvasWidth * dpr);
    plot.height = Math.floor(canvasHeight * dpr);
    g.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas, {passive:true});
  resizeCanvas();

  // ===== State
  let audioCtx=null, source=null, processor=null, stream=null, workletUrl=null;
  let ema=0, running=false, calibrating=false, calibEnd=0;
  let envHistory=[], derPrev=0, prevEma=0;
  let lastPeak=null, lastTrough=null, inhaleStartT=null;
  let lastCycle=null, cycles=[];
  let currentTrace=[], ghostTraces=[], traceStartTime=null;
  let paceOn=false, paceStart=0;
  let lastEnvelopeTime=null;
  let currentPhase='';
  let recording=false, recordSegments=[], activeRecordSegment=null;
  let lastDisplayRatio=0, lastPlotStoreTime=0;
  let orbTargetRatio=0, orbDisplayedRatio=0, orbPhase='';
  let orbTimer=null;
  let resumeBound=false;

  // UI binds
  alphaRange.oninput=()=>alphaVal.textContent=(+alphaRange.value).toFixed(2);
  calibRange.oninput=()=>calibVal.textContent=calibRange.value;
  sensRange.oninput=()=>sensVal.textContent=sensLabels[sensRange.value|0];
  gainRange.oninput=()=>gainVal.textContent=gainRange.value+'×';
  quick6.onclick=(e)=>{
    e.preventDefault();
    paceOn=!paceOn;
    paceStart=performance.now()/1000;
    quick6.textContent=paceOn?'Остановить метроном':'Пейсинг 6 бр/мин';
  };

  alphaRange.oninput();
  calibRange.oninput();
  sensRange.oninput();
  gainRange.oninput();
  updateRecordingUI();

  function updateRecordingUI(){
    recordBtn.textContent = recording ? 'Идёт запись' : 'Запись';
    recordBtn.classList.toggle('recording', recording);
    recordBadge.classList.toggle('on', recording);
    recordBadge.textContent = recording ? 'Идёт запись' : 'Нет записи';
  }

  function currentTime(){
    return (lastEnvelopeTime ?? audioCtx?.currentTime) || performance.now()/1000;
  }

  function trimRecordSegments(now=currentTime()){
    const horizon = HISTORY_SEC * (MAX_GHOSTS + 1);
    recordSegments = recordSegments.filter(seg=>{
      const end = seg.end ?? now;
      return now - end < horizon;
    });
  }

  function setRecordingState(next){
    if (next === recording) return;
    recording = next;
    if (recording){
      activeRecordSegment = {start:currentTime(), end:null};
      recordSegments.push(activeRecordSegment);
      trimRecordSegments();
    } else if (activeRecordSegment){
      activeRecordSegment.end = currentTime();
      activeRecordSegment=null;
    }
    updateRecordingUI();
  }

  function isRecordedAt(time){
    const now = currentTime();
    return recordSegments.some(seg=>{
      const segEnd = seg.end ?? now;
      return time >= seg.start && time <= segEnd;
    });
  }

  function storeTracePoint(now, value){
    if (traceStartTime==null){
      traceStartTime = now;
    }
    let offset = now - traceStartTime;
    if (offset >= HISTORY_SEC){
      finalizeTrace();
      currentTrace = [];
      traceStartTime = now;
      offset = 0;
    }
    currentTrace.push({t:offset, db:rmsToDb(value)});
  }

  function finalizeTrace(){
    if (!currentTrace.length) return;
    const ghost = buildGhostTrace(currentTrace);
    if (!ghost.length) return;
    ghostTraces.unshift(ghost);
    if (ghostTraces.length>MAX_GHOSTS) ghostTraces.pop();
  }

  function buildGhostTrace(points){
    if (!points.length) return [];
    const step = HISTORY_SEC / GHOST_RESOLUTION;
    const ghost=[];
    for (let i=0; i<=GHOST_RESOLUTION; i++){
      const t = Math.min(HISTORY_SEC, i*step);
      ghost.push({t, db: sampleTraceAt(points, t)});
    }
    return ghost;
  }

  function sampleTraceAt(points, targetT){
    if (!points.length) return DB_MIN;
    if (targetT <= points[0].t) return points[0].db;
    for (let i=1; i<points.length; i++){
      const prev = points[i-1];
      const curr = points[i];
      if (targetT <= curr.t){
        const span = Math.max(0.0001, curr.t - prev.t);
        const ratio = (targetT - prev.t)/span;
        return prev.db + ratio*(curr.db - prev.db);
      }
    }
    return points[points.length-1].db;
  }

  function setPhase(phase){
    currentPhase = phase || '';
    phaseEl.textContent = currentPhase || '—';
    if (running && !calibrating){
      statusEl.textContent = currentPhase || 'Поток активен';
    }
  }

  // ===== Start/Stop
  async function ensureRunning(){
    if (running) return true;
    try{
      await start();
      return true;
    }catch(e){
      console.warn('Не удалось запустить поток', e);
      return false;
    }
  }

  function bindResumeHandler(){
    if (resumeBound) return;
    const resume = ()=>{ if (audioCtx && audioCtx.state==='suspended'){ audioCtx.resume(); } };
    ['touchstart','pointerdown'].forEach(evt=>{
      window.addEventListener(evt, resume, {passive:true});
    });
    resumeBound=true;
  }

  async function start(){
    if (running) return;
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
      });
    }catch(e){
      statusEl.textContent = 'Нужен доступ к микрофону';
      phaseEl.textContent = '—';
      updateRecordingUI();
      throw e;
    }
    audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    bindResumeHandler();
    source = audioCtx.createMediaStreamSource(stream);

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = +gainRange.value;

    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=20;

    try{
      processor = await createWorkletNode();
    }catch(e){
      alert('AudioWorklet недоступен: '+e.message);
      stop();
      return;
    }

    source.connect(gainNode);
    gainNode.connect(hp);
    hp.connect(processor);
    processor.connect(audioCtx.destination);

    resetLogic(true);
    running=true; calibrate();
    statusEl.textContent='Калибровка...';
    phaseEl.textContent='—';
  }

  function stop(){
    running=false; calibrating=false;
    if (processor){
      try{processor.disconnect();}catch{}
      if (processor.port) processor.port.onmessage=null;
    }
    if (audioCtx){ try{audioCtx.close();}catch{} }
    if (stream){ stream.getTracks().forEach(t=>t.stop()); }
    if (workletUrl){ URL.revokeObjectURL(workletUrl); workletUrl=null; }
    audioCtx=source=processor=stream=null;
    resetLogic(false, {preserveTraces:true});
    setRecordingState(false);
    recordSegments=[]; activeRecordSegment=null;
    statusEl.textContent='Ожидание';
    lvlbar.style.width='0%';
    brpmEl.textContent=inhEl.textContent=exhEl.textContent=ieEl.textContent=cohEl.textContent='—';
    paceOn=false; quick6.textContent='Пейсинг 6 бр/мин';
    updateOrb(0,'');
  }

  recordBtn.onclick=async ()=>{
    const ok = await ensureRunning();
    if (!ok) return;
    setRecordingState(!recording);
  };
  stopBtn.onclick=()=>{
    stop();
  };

  async function createWorkletNode(){
    if (!audioCtx || !audioCtx.audioWorklet || typeof AudioWorkletNode === 'undefined'){
      throw new Error('браузер не поддерживает AudioWorklet');
    }
    workletUrl = URL.createObjectURL(new Blob([WORKLET_SOURCE], {type:'application/javascript'}));
    await audioCtx.audioWorklet.addModule(workletUrl);
    const node = new AudioWorkletNode(audioCtx,'rms-processor',{
      numberOfInputs:1,
      numberOfOutputs:1,
      outputChannelCount:[1]
    });
    node.port.onmessage = e => handleEnvelope(e.data);
    return node;
  }

  // ===== Core processing
  function handleEnvelope(payload){
    if (!audioCtx) return;
    const msg = (typeof payload === 'number') ? {rms:payload, frames:REF_BLOCK} : (payload || {});
    const rms = msg.rms ?? 0;
    const frames = msg.frames || REF_BLOCK;

    const alphaUser = +alphaRange.value;
    const scaledAlpha = 1 - Math.pow(1 - alphaUser, Math.max(1, frames)/REF_BLOCK);
    ema = scaledAlpha*rms + (1-scaledAlpha)*ema;

    envHistory.push(ema);
    if (envHistory.length > 4800) envHistory.shift();

    const der = ema - prevEma;
    prevEma = ema;

    if (lastEnvelopeTime==null) lastEnvelopeTime = audioCtx.currentTime;
    else lastEnvelopeTime += frames / audioCtx.sampleRate;
    const now = lastEnvelopeTime;
    trimRecordSegments(now);

    if (now - lastPlotStoreTime >= DRAW_INTERVAL){
      storeTracePoint(now, ema);
      lastPlotStoreTime = now;
    }

    const {median, mad} = robustStats(envHistory);
    const safeMad = Math.max(mad, MIN_MAD);
    const hi = median + (1.8 + sensShift[sensRange.value|0]) * safeMad;
    const lo = Math.max(median - 0.2*safeMad, 0);

    if (derPrev>0 && der<=0 && ema>hi){
      lastPeak = {t:now, v:ema};
      setPhase('Выдох', now);
      if (lastTrough){
        const tInhale = now - lastTrough.t;
        if (!lastCycle) lastCycle={};
        lastCycle.tInhale = clampInRange(tInhale,0.3,15)?tInhale:undefined;
        inhaleStartT = lastTrough.t;
      }
    }

    if (derPrev<0 && der>=0 && ema<lo){
      lastTrough = {t:now, v:ema};
      setPhase('Вдох', now);
      if (lastPeak){
        const tExhale = now - lastPeak.t;
        if (!lastCycle) lastCycle={};
        lastCycle.tExhale = clampInRange(tExhale,0.3,20)?tExhale:undefined;

        if (inhaleStartT!=null){
          lastCycle.tStart = inhaleStartT;
          lastCycle.tEnd = now;
          lastCycle.tCycle = (lastCycle.tInhale||0) + (lastCycle.tExhale||0);
          lastCycle.peakV = lastPeak.v; lastCycle.troughV = lastTrough.v;
          const swing = Math.abs((lastCycle.peakV||0) - (lastCycle.troughV||0));
          const minSwing = Math.max(MIN_SWING, 0.35*safeMad);
          if (clampInRange(lastCycle.tCycle,1.5,15) && swing>=minSwing){
            cycles.push(lastCycle);
            if (cycles.length>120) cycles.shift();
          }
          lastCycle.recorded = isRecordedAt(now);
          lastCycle = {};
        }
      }
    }
    derPrev = der;

    if (calibrating){
      const remain = Math.max(0, calibEnd - now);
      statusEl.textContent = `Калибровка: ${remain.toFixed(1)} с`;
      if (remain<=0){
        calibrating=false;
        statusEl.textContent = currentPhase || 'Поток активен';
      }
    } else if (running){
      statusEl.textContent = currentPhase || 'Поток активен';
    }
    phaseEl.textContent = currentPhase || '—';

    updateStats(ema);
  }

  function resetLogic(full=false, options={}){
    const preserveTraces = !!options.preserveTraces;
    ema=0; envHistory=[]; derPrev=0; prevEma=0; lastPeak=lastTrough=null; inhaleStartT=null;
    lastEnvelopeTime=null; lastPlotStoreTime=0;
    setPhase('');
    if (full){
      cycles=[]; lastCycle=null;
      if (!preserveTraces){
        currentTrace=[]; ghostTraces=[]; traceStartTime=null;
      }
    } else if (!preserveTraces){
      traceStartTime=null;
    }
  }
  function currentBRPM(){
    if (cycles.length<2) return null;
    const lastN=cycles.slice(-5).map(c=>c.tCycle).filter(Boolean);
    if (!lastN.length) return null;
    const med=lastN.sort((a,b)=>a-b)[Math.floor(lastN.length/2)];
    return med?60/med:null;
  }
  function updateStats(level){
    const ratio = rmsToRatio(level);
    lastDisplayRatio = ratio;
    lvlbar.style.width = (ratio*100).toFixed(0)+'%';
    updateOrb(ratio, currentPhase);

    const br = currentBRPM();
    brpmEl.textContent = br ? br.toFixed(1) : '—';

    const last = cycles[cycles.length-1];
    inhEl.textContent = last?.tInhale ? last.tInhale.toFixed(2) : '—';
    exhEl.textContent = last?.tExhale ? last.tExhale.toFixed(2) : '—';
    ieEl.textContent  = (last?.tInhale && last?.tExhale) ? (last.tInhale/last.tExhale).toFixed(2) : '—';

    const last8 = cycles.slice(-8).map(c=>c.tCycle).filter(Boolean);
    if (last8.length>=3){
      const mean = last8.reduce((s,x)=>s+x,0)/last8.length;
      const sd   = Math.sqrt(last8.reduce((s,x)=>s+(x-mean)*(x-mean),0)/last8.length);
      let coh = 1 - (sd/mean);
      coh = Math.max(0, Math.min(1, coh));
      cohEl.textContent = Math.round(coh*100);
    } else cohEl.textContent='—';
  }

  // ===== Drawing
  function drawLoop(){
    g.clearRect(0,0,canvasWidth,canvasHeight);
    const pxPerSec = canvasWidth / HISTORY_SEC;

    g.strokeStyle='#e5e7eb'; g.lineWidth=1; g.globalAlpha=1;
    g.beginPath();
    for (let sec=0; sec<=HISTORY_SEC; sec+=5){
      const x = sec*pxPerSec;
      g.moveTo(x,0); g.lineTo(x,canvasHeight);
    }
    const dbStep = 10;
    for (let db = DB_MIN; db<=DB_MAX; db+=dbStep){
      const y = dbToY(db);
      g.moveTo(0,y); g.lineTo(canvasWidth,y);
    }
    g.stroke();

    g.fillStyle='#94a3b8'; g.font='12px "Inter", system-ui';
    g.textBaseline='bottom';
    for (let sec=0; sec<=HISTORY_SEC; sec+=10){
      const x = Math.max(4, Math.min(canvasWidth-34, sec*pxPerSec + 4));
      g.fillText(`${sec} с`, x, canvasHeight-4);
    }
    g.textBaseline='middle';
    for (let db = DB_MIN; db<=DB_MAX; db+=10){
      const y = dbToY(db);
      g.fillText(`${db} дБ`, 6, Math.max(10, Math.min(canvasHeight-10, y)));
    }

    if (currentPhase){
      g.save();
      g.globalAlpha=0.08;
      g.fillStyle = currentPhase==='Вдох' ? 'var(--good)' : 'var(--warn)';
      g.fillRect(0, canvasHeight-40, canvasWidth, 40);
      g.restore();
    }

    if (recordSegments.length && traceStartTime!=null){
      const windowStart = traceStartTime;
      const windowEnd = windowStart + HISTORY_SEC;
      g.save();
      g.fillStyle='rgba(239,68,68,0.06)';
      recordSegments.forEach(seg=>{
        const segEnd = Math.min(seg.end ?? currentTime(), windowEnd);
        const segStart = Math.max(seg.start, windowStart);
        if (segEnd <= windowStart || segStart >= windowEnd) return;
        const x1 = ((segStart - windowStart)/HISTORY_SEC)*canvasWidth;
        const x2 = ((segEnd - windowStart)/HISTORY_SEC)*canvasWidth;
        g.fillRect(x1,0,Math.max(2,x2-x1),canvasHeight);
      });
      g.restore();
    }

    const renderTrace=(points,color,width,alpha=1)=>{
      if (!points || points.length<2) return;
      g.save();
      g.lineWidth=width;
      g.strokeStyle=color;
      g.globalAlpha=alpha;
      g.lineCap='round';
      g.lineJoin='round';
      g.beginPath();
      points.forEach((pt, idx)=>{
        const x = Math.max(0, Math.min(canvasWidth, (pt.t / HISTORY_SEC)*canvasWidth));
        const y = dbToY(pt.db);
        if (idx===0) g.moveTo(x,y); else g.lineTo(x,y);
      });
      g.stroke();
      g.restore();
    };

    ghostTraces.forEach((trace, idx)=>{
      const alpha = Math.max(0.08, 0.35 - idx*0.05);
      renderTrace(trace, '#94a3b8', 1.4, alpha);
    });

    if (currentTrace.length){
      renderTrace(currentTrace, '#1d4ed8', 3.2, 1);
    }

    if (paceOn){
      const t = performance.now()/1000 - paceStart;
      const period = 10, inhaleFrac = 0.45;
      const ph = (t%period)/period;
      const inhale = ph<inhaleFrac;
      const r = 10 + (inhale? (ph/inhaleFrac):(1-(ph-inhaleFrac)/(1-inhaleFrac)))*20;
      g.save();
      g.globalAlpha=0.9;
      g.fillStyle = inhale? 'var(--good)' : 'var(--warn)';
      g.beginPath(); g.arc(canvasWidth-30, canvasHeight-30, r, 0, Math.PI*2); g.fill();
      g.restore();
    }
    requestAnimationFrame(drawLoop);
  }

  function updateOrb(ratio, phase){
    orbTargetRatio = Math.max(0, Math.min(1, isFinite(ratio)?ratio:0));
    orbPhase = phase || '';
    if (!orbTimer){
      orbTimer = setInterval(renderOrbFrame, ORB_INTERVAL_MS);
    }
  }

  function renderOrbFrame(){
    if (!orb) return;
    const diff = orbTargetRatio - orbDisplayedRatio;
    orbDisplayedRatio += diff * 0.35;
    const size = ORB_MIN + (ORB_MAX - ORB_MIN) * orbDisplayedRatio;
    orb.style.width = size.toFixed(1)+'px';
    orb.style.height = size.toFixed(1)+'px';
    orb.style.boxShadow = `0 8px 30px rgba(37,99,235,${0.25 + orbDisplayedRatio*0.35})`;
    orb.classList.toggle('inhale', orbPhase==='Вдох');
    orb.classList.toggle('exhale', orbPhase==='Выдох');
    orb.classList.toggle('idle', !running);
  }
  requestAnimationFrame(drawLoop);
  renderOrbFrame();

  window.addEventListener('load', ()=>{
    ensureRunning();
  });

  // ===== Export
  exportBtn.onclick = () => {
    const recordedOnly = cycles.filter(c=>c.recorded);
    const dataset = recordedOnly.length ? recordedOnly : cycles;
    const rows = [['t_start(s)','t_end(s)','cycle(s)','inhale(s)','exhale(s)','brpm','I:E','peak_amp','trough_amp','recorded']];
    for (const c of dataset) {
      const brpm = c.tCycle?60/c.tCycle:'';
      const ie = (c.tInhale&&c.tExhale)?(c.tInhale/c.tExhale).toFixed(2):'';
      rows.push([
        c.tStart?.toFixed(3)||'',
        c.tEnd?.toFixed(3)||'',
        c.tCycle?.toFixed(3)||'',
        c.tInhale?.toFixed(3)||'',
        c.tExhale?.toFixed(3)||'',
        brpm?brpm.toFixed(2):'',
        ie,
        c.peakV?.toFixed(5)||'',
        c.troughV?.toFixed(5)||'',
        c.recorded?1:0
      ]);
    }
    download('breath_session.csv', rows.map(r=>r.join(',')).join('\n'));
  };

  // ===== Calibration
  function calibrate(){
    if (!audioCtx) return;
    calibrating=true;
    calibEnd = audioCtx.currentTime + (parseInt(calibRange.value,10)||5);
    statusEl.textContent='Калибровка...';
    phaseEl.textContent = currentPhase || '—';
  }

})();
</script>
</body>
</html>
